          // can be just the necessary schema
  class %(tupletypename)s {

    public:
    // relies on std::tuple having predictable field sizes if all fields are same size
    std::tuple<%(fieldtypes)s> _fields;

    template <int field>
    int64_t get() const {
      return std::get<field>(_fields);
    }

    template <int field, typename T>
    void set(T val) {
      std::get<field>(_fields) = val;
    }

    static constexpr int numFields() {
      return %(numfields)s;
    }

    %(tupletypename)s () {
      // no-op
    }

    %(tupletypename)s (const decltype(_fields)& data) {
      std::memcpy(&_fields, &data, sizeof(_fields));
    }

    // shamelessly terrible disambiguation: one solution is named factory methods
    %(tupletypename)s (std::vector<int64_t> vals, bool ignore1, bool ignore2) {
      std::memcpy(&_fields, &vals[0], sizeof(_fields));
    }

    // note not typesafe!!
    template <typename T1, typename T2>
    static %(tupletypename)s create(T1& t1, T2& t2) {
      //TODO: format of assertion for type safe memcpy; fo this for each field
      //static_assert(!(std::is_integral<typename std::tuple_element<field,decltype(_fields)>::type>::value ^ std::is_integral<T>::value), "Type mismatch");

        static_assert(%(tupletypename)s::numFields() == (T1::numFields() + T2::numFields()), "lhs and rhs must have equal number of fields");
        %(tupletypename)s t;
        std::memcpy(&(t._fields), &(t1._fields), T1::numFields()*sizeof(int64_t));
        std::memcpy(((char*)&(t._fields))+T1::numFields*sizeof(int64_t), &(t2._fields), T2::numFields()*sizeof(int64_t));
        return t;
    }

    template <typename T>
    static %(tupletypename)s create(T& from) {
      static_assert(%(tupletypename)s::numFields() == T::numFields(), "constructor only works on same num fields");
      %(tupletypename)s t;
      std::memcpy(&(t._fields), &(from._fields), from.numFields()*sizeof(int64_t));
      return t;
    }

    template <typename Tuple, typename T>
    %(tupletypename)s (Tuple& v0, T& from) {
        static_assert(%(tupletypename)s::numFields() == (std::tuple_size<Tuple>::value + T::numFields()), "constructor only works on same number of total fields");
        std::memcpy(&_fields, &v0, sizeof(Tuple));
        std::memcpy(((char*)&_fields)+sizeof(Tuple), &(from._fields), T::numFields());
    }

    std::ostream& dump(std::ostream& o) const {
      o << "Materialized(";

      // for (int i=0; i<numFields(); i++) {
      //  o << _fields[i] << ",";
      // }
      %(string_append_statements)s

      o << ")";
      return o;
    }

    %(additional_code)s
  } %(after_def_code)s;

  std::ostream& operator<< (std::ostream& o, const %(tupletypename)s& t) {
    return t.dump(o);
  }

