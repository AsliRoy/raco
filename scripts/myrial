#!/usr/bin/env python

"""Compile a Myrial program into a physical plan."""

import raco.myrial.interpreter as interpreter
import raco.myrial.parser as parser
import raco.scheme
import raco.catalog
from raco.fakedb import FakeDatabase

from raco import algebra
from raco.viz import operator_to_dot
from raco.myrial.exceptions import *

import argparse
import os
import json
import sys

def print_pretty_plan(plan, indent=0):
    if isinstance(plan, algebra.DoWhile):
        children = plan.children()
        body = children[:-1]
        term = children[-1]

        spc = ' ' * indent
        print '%sDO' % spc
        for op in body:
            print_pretty_plan(op, indent + 4)
        print '%sWHILE' % spc
        print_pretty_plan(term, indent + 4)
    elif isinstance(plan, algebra.Sequence):
        print '%s%s' % (' ' * indent, plan.shortStr())
        for child in plan.children():
            print_pretty_plan(child, indent + 4)
    else:
        print '%s%s' % (' ' * indent, plan)

def parse_options(args):
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    group.add_argument('-p', dest='parse',
                        help="Generate AST (parse tree)", action='store_true')
    group.add_argument('-l', dest='logical',
                        help="Generate logical plan", action='store_true')
    group.add_argument('-d', dest='dot',
                       help="Generate dot output for logical plan",
                       action='store_true')
    group.add_argument('-j', dest='json',
                        help="Encode plan as JSON", action='store_true')
    group.add_argument('-r', dest='repr',
                        help="Encode plan as Python repr", action='store_true')
    group.add_argument('-f', dest='standalone', action='store_true',
                       help='Execute the program in standalone mode')
    parser.add_argument('file', help='File containing Myrial source program')

    ns = parser.parse_args(args)
    return ns

class FakeCatalog(raco.catalog.Catalog):
    def __init__(self, catalog):
        self.catalog = catalog

    def get_scheme(self, rel_key):
        string_key = str(rel_key)
        return raco.scheme.Scheme(self.catalog[string_key])

    @classmethod
    def load_from_file(cls, path):
        with open(path) as fh:
            return cls(eval(fh.read()))

    def get_num_servers(self):
        return 1

    def num_tuples(self, rel_key):
        return algebra.DEFAULT_CARDINALITY

def main(args):
    opt = parse_options(args)

    # Search for a catalog definition file
    catalog_path = os.path.join(os.path.dirname(opt.file), 'catalog.py')
    if os.path.exists(catalog_path):
        catalog = FakeCatalog.load_from_file(catalog_path)
    else:
        catalog = FakeCatalog({})

    _parser = parser.Parser()
    processor = interpreter.StatementProcessor(catalog, True)

    with open(opt.file) as fh:
        try:
            statement_list = _parser.parse(fh.read())
        except MyrialCompileException as ex:
            print 'Myrial parse error: %s' % ex
            return 1

        if opt.parse:
            print statement_list
        else:
            processor.evaluate(statement_list)
            if opt.logical:
                print_pretty_plan(processor.get_logical_plan())
            elif opt.dot:
                print operator_to_dot(processor.get_logical_plan())
            elif opt.json:
                print json.dumps(processor.get_json())
            elif opt.standalone:
                pp = processor.get_physical_plan()
                db = FakeDatabase()
                db.evaluate(pp)
            elif opt.repr:
                pp = processor.get_physical_plan()
                print repr(pp)
            else:
                print_pretty_plan(processor.get_physical_plan())

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
